// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chunkserver.proto

#ifndef PROTOBUF_INCLUDED_chunkserver_2eproto
#define PROTOBUF_INCLUDED_chunkserver_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_chunkserver_2eproto 

namespace protobuf_chunkserver_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_chunkserver_2eproto
namespace chunkserver {
class AllocateInodeReq;
class AllocateInodeReqDefaultTypeInternal;
extern AllocateInodeReqDefaultTypeInternal _AllocateInodeReq_default_instance_;
class AllocateInodeRsp;
class AllocateInodeRspDefaultTypeInternal;
extern AllocateInodeRspDefaultTypeInternal _AllocateInodeRsp_default_instance_;
class ReadSliceReq;
class ReadSliceReqDefaultTypeInternal;
extern ReadSliceReqDefaultTypeInternal _ReadSliceReq_default_instance_;
class ReadSliceRsp;
class ReadSliceRspDefaultTypeInternal;
extern ReadSliceRspDefaultTypeInternal _ReadSliceRsp_default_instance_;
class SetChunkStatusReq;
class SetChunkStatusReqDefaultTypeInternal;
extern SetChunkStatusReqDefaultTypeInternal _SetChunkStatusReq_default_instance_;
class SetChunkStatusRsp;
class SetChunkStatusRspDefaultTypeInternal;
extern SetChunkStatusRspDefaultTypeInternal _SetChunkStatusRsp_default_instance_;
class WriteSliceReq;
class WriteSliceReqDefaultTypeInternal;
extern WriteSliceReqDefaultTypeInternal _WriteSliceReq_default_instance_;
class WriteSliceRsp;
class WriteSliceRspDefaultTypeInternal;
extern WriteSliceRspDefaultTypeInternal _WriteSliceRsp_default_instance_;
}  // namespace chunkserver
namespace google {
namespace protobuf {
template<> ::chunkserver::AllocateInodeReq* Arena::CreateMaybeMessage<::chunkserver::AllocateInodeReq>(Arena*);
template<> ::chunkserver::AllocateInodeRsp* Arena::CreateMaybeMessage<::chunkserver::AllocateInodeRsp>(Arena*);
template<> ::chunkserver::ReadSliceReq* Arena::CreateMaybeMessage<::chunkserver::ReadSliceReq>(Arena*);
template<> ::chunkserver::ReadSliceRsp* Arena::CreateMaybeMessage<::chunkserver::ReadSliceRsp>(Arena*);
template<> ::chunkserver::SetChunkStatusReq* Arena::CreateMaybeMessage<::chunkserver::SetChunkStatusReq>(Arena*);
template<> ::chunkserver::SetChunkStatusRsp* Arena::CreateMaybeMessage<::chunkserver::SetChunkStatusRsp>(Arena*);
template<> ::chunkserver::WriteSliceReq* Arena::CreateMaybeMessage<::chunkserver::WriteSliceReq>(Arena*);
template<> ::chunkserver::WriteSliceRsp* Arena::CreateMaybeMessage<::chunkserver::WriteSliceRsp>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace chunkserver {

// ===================================================================

class SetChunkStatusReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chunkserver.SetChunkStatusReq) */ {
 public:
  SetChunkStatusReq();
  virtual ~SetChunkStatusReq();

  SetChunkStatusReq(const SetChunkStatusReq& from);

  inline SetChunkStatusReq& operator=(const SetChunkStatusReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetChunkStatusReq(SetChunkStatusReq&& from) noexcept
    : SetChunkStatusReq() {
    *this = ::std::move(from);
  }

  inline SetChunkStatusReq& operator=(SetChunkStatusReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetChunkStatusReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetChunkStatusReq* internal_default_instance() {
    return reinterpret_cast<const SetChunkStatusReq*>(
               &_SetChunkStatusReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(SetChunkStatusReq* other);
  friend void swap(SetChunkStatusReq& a, SetChunkStatusReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetChunkStatusReq* New() const final {
    return CreateMaybeMessage<SetChunkStatusReq>(NULL);
  }

  SetChunkStatusReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetChunkStatusReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetChunkStatusReq& from);
  void MergeFrom(const SetChunkStatusReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetChunkStatusReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 chunk_id = 1;
  void clear_chunk_id();
  static const int kChunkIdFieldNumber = 1;
  ::google::protobuf::uint64 chunk_id() const;
  void set_chunk_id(::google::protobuf::uint64 value);

  // uint32 status_to_set = 2;
  void clear_status_to_set();
  static const int kStatusToSetFieldNumber = 2;
  ::google::protobuf::uint32 status_to_set() const;
  void set_status_to_set(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chunkserver.SetChunkStatusReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 chunk_id_;
  ::google::protobuf::uint32 status_to_set_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chunkserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetChunkStatusRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chunkserver.SetChunkStatusRsp) */ {
 public:
  SetChunkStatusRsp();
  virtual ~SetChunkStatusRsp();

  SetChunkStatusRsp(const SetChunkStatusRsp& from);

  inline SetChunkStatusRsp& operator=(const SetChunkStatusRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetChunkStatusRsp(SetChunkStatusRsp&& from) noexcept
    : SetChunkStatusRsp() {
    *this = ::std::move(from);
  }

  inline SetChunkStatusRsp& operator=(SetChunkStatusRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetChunkStatusRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetChunkStatusRsp* internal_default_instance() {
    return reinterpret_cast<const SetChunkStatusRsp*>(
               &_SetChunkStatusRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SetChunkStatusRsp* other);
  friend void swap(SetChunkStatusRsp& a, SetChunkStatusRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetChunkStatusRsp* New() const final {
    return CreateMaybeMessage<SetChunkStatusRsp>(NULL);
  }

  SetChunkStatusRsp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetChunkStatusRsp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetChunkStatusRsp& from);
  void MergeFrom(const SetChunkStatusRsp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetChunkStatusRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chunkserver.SetChunkStatusRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chunkserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AllocateInodeReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chunkserver.AllocateInodeReq) */ {
 public:
  AllocateInodeReq();
  virtual ~AllocateInodeReq();

  AllocateInodeReq(const AllocateInodeReq& from);

  inline AllocateInodeReq& operator=(const AllocateInodeReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AllocateInodeReq(AllocateInodeReq&& from) noexcept
    : AllocateInodeReq() {
    *this = ::std::move(from);
  }

  inline AllocateInodeReq& operator=(AllocateInodeReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AllocateInodeReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllocateInodeReq* internal_default_instance() {
    return reinterpret_cast<const AllocateInodeReq*>(
               &_AllocateInodeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(AllocateInodeReq* other);
  friend void swap(AllocateInodeReq& a, AllocateInodeReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AllocateInodeReq* New() const final {
    return CreateMaybeMessage<AllocateInodeReq>(NULL);
  }

  AllocateInodeReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AllocateInodeReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AllocateInodeReq& from);
  void MergeFrom(const AllocateInodeReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllocateInodeReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 chunk_id = 1;
  void clear_chunk_id();
  static const int kChunkIdFieldNumber = 1;
  ::google::protobuf::uint64 chunk_id() const;
  void set_chunk_id(::google::protobuf::uint64 value);

  // uint32 data_length = 2;
  void clear_data_length();
  static const int kDataLengthFieldNumber = 2;
  ::google::protobuf::uint32 data_length() const;
  void set_data_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chunkserver.AllocateInodeReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 chunk_id_;
  ::google::protobuf::uint32 data_length_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chunkserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AllocateInodeRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chunkserver.AllocateInodeRsp) */ {
 public:
  AllocateInodeRsp();
  virtual ~AllocateInodeRsp();

  AllocateInodeRsp(const AllocateInodeRsp& from);

  inline AllocateInodeRsp& operator=(const AllocateInodeRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AllocateInodeRsp(AllocateInodeRsp&& from) noexcept
    : AllocateInodeRsp() {
    *this = ::std::move(from);
  }

  inline AllocateInodeRsp& operator=(AllocateInodeRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AllocateInodeRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllocateInodeRsp* internal_default_instance() {
    return reinterpret_cast<const AllocateInodeRsp*>(
               &_AllocateInodeRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AllocateInodeRsp* other);
  friend void swap(AllocateInodeRsp& a, AllocateInodeRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AllocateInodeRsp* New() const final {
    return CreateMaybeMessage<AllocateInodeRsp>(NULL);
  }

  AllocateInodeRsp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AllocateInodeRsp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AllocateInodeRsp& from);
  void MergeFrom(const AllocateInodeRsp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AllocateInodeRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 slice_id = 1;
  void clear_slice_id();
  static const int kSliceIdFieldNumber = 1;
  ::google::protobuf::uint64 slice_id() const;
  void set_slice_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:chunkserver.AllocateInodeRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 slice_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chunkserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadSliceReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chunkserver.ReadSliceReq) */ {
 public:
  ReadSliceReq();
  virtual ~ReadSliceReq();

  ReadSliceReq(const ReadSliceReq& from);

  inline ReadSliceReq& operator=(const ReadSliceReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadSliceReq(ReadSliceReq&& from) noexcept
    : ReadSliceReq() {
    *this = ::std::move(from);
  }

  inline ReadSliceReq& operator=(ReadSliceReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadSliceReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadSliceReq* internal_default_instance() {
    return reinterpret_cast<const ReadSliceReq*>(
               &_ReadSliceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ReadSliceReq* other);
  friend void swap(ReadSliceReq& a, ReadSliceReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadSliceReq* New() const final {
    return CreateMaybeMessage<ReadSliceReq>(NULL);
  }

  ReadSliceReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadSliceReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadSliceReq& from);
  void MergeFrom(const ReadSliceReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadSliceReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 slice_id = 1;
  void clear_slice_id();
  static const int kSliceIdFieldNumber = 1;
  ::google::protobuf::uint64 slice_id() const;
  void set_slice_id(::google::protobuf::uint64 value);

  // uint32 offset = 2;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // uint32 length_to_read = 3;
  void clear_length_to_read();
  static const int kLengthToReadFieldNumber = 3;
  ::google::protobuf::uint32 length_to_read() const;
  void set_length_to_read(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chunkserver.ReadSliceReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 slice_id_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 length_to_read_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chunkserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadSliceRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chunkserver.ReadSliceRsp) */ {
 public:
  ReadSliceRsp();
  virtual ~ReadSliceRsp();

  ReadSliceRsp(const ReadSliceRsp& from);

  inline ReadSliceRsp& operator=(const ReadSliceRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadSliceRsp(ReadSliceRsp&& from) noexcept
    : ReadSliceRsp() {
    *this = ::std::move(from);
  }

  inline ReadSliceRsp& operator=(ReadSliceRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadSliceRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadSliceRsp* internal_default_instance() {
    return reinterpret_cast<const ReadSliceRsp*>(
               &_ReadSliceRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ReadSliceRsp* other);
  friend void swap(ReadSliceRsp& a, ReadSliceRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadSliceRsp* New() const final {
    return CreateMaybeMessage<ReadSliceRsp>(NULL);
  }

  ReadSliceRsp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadSliceRsp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadSliceRsp& from);
  void MergeFrom(const ReadSliceRsp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadSliceRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // uint32 data_length = 1;
  void clear_data_length();
  static const int kDataLengthFieldNumber = 1;
  ::google::protobuf::uint32 data_length() const;
  void set_data_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chunkserver.ReadSliceRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 data_length_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chunkserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteSliceReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chunkserver.WriteSliceReq) */ {
 public:
  WriteSliceReq();
  virtual ~WriteSliceReq();

  WriteSliceReq(const WriteSliceReq& from);

  inline WriteSliceReq& operator=(const WriteSliceReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteSliceReq(WriteSliceReq&& from) noexcept
    : WriteSliceReq() {
    *this = ::std::move(from);
  }

  inline WriteSliceReq& operator=(WriteSliceReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteSliceReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteSliceReq* internal_default_instance() {
    return reinterpret_cast<const WriteSliceReq*>(
               &_WriteSliceReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(WriteSliceReq* other);
  friend void swap(WriteSliceReq& a, WriteSliceReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteSliceReq* New() const final {
    return CreateMaybeMessage<WriteSliceReq>(NULL);
  }

  WriteSliceReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteSliceReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteSliceReq& from);
  void MergeFrom(const WriteSliceReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteSliceReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 3;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // uint64 slice_id = 1;
  void clear_slice_id();
  static const int kSliceIdFieldNumber = 1;
  ::google::protobuf::uint64 slice_id() const;
  void set_slice_id(::google::protobuf::uint64 value);

  // uint32 offset = 2;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chunkserver.WriteSliceReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint64 slice_id_;
  ::google::protobuf::uint32 offset_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chunkserver_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteSliceRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chunkserver.WriteSliceRsp) */ {
 public:
  WriteSliceRsp();
  virtual ~WriteSliceRsp();

  WriteSliceRsp(const WriteSliceRsp& from);

  inline WriteSliceRsp& operator=(const WriteSliceRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteSliceRsp(WriteSliceRsp&& from) noexcept
    : WriteSliceRsp() {
    *this = ::std::move(from);
  }

  inline WriteSliceRsp& operator=(WriteSliceRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteSliceRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteSliceRsp* internal_default_instance() {
    return reinterpret_cast<const WriteSliceRsp*>(
               &_WriteSliceRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(WriteSliceRsp* other);
  friend void swap(WriteSliceRsp& a, WriteSliceRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteSliceRsp* New() const final {
    return CreateMaybeMessage<WriteSliceRsp>(NULL);
  }

  WriteSliceRsp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteSliceRsp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteSliceRsp& from);
  void MergeFrom(const WriteSliceRsp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteSliceRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chunkserver.WriteSliceRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_chunkserver_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SetChunkStatusReq

// uint64 chunk_id = 1;
inline void SetChunkStatusReq::clear_chunk_id() {
  chunk_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SetChunkStatusReq::chunk_id() const {
  // @@protoc_insertion_point(field_get:chunkserver.SetChunkStatusReq.chunk_id)
  return chunk_id_;
}
inline void SetChunkStatusReq::set_chunk_id(::google::protobuf::uint64 value) {
  
  chunk_id_ = value;
  // @@protoc_insertion_point(field_set:chunkserver.SetChunkStatusReq.chunk_id)
}

// uint32 status_to_set = 2;
inline void SetChunkStatusReq::clear_status_to_set() {
  status_to_set_ = 0u;
}
inline ::google::protobuf::uint32 SetChunkStatusReq::status_to_set() const {
  // @@protoc_insertion_point(field_get:chunkserver.SetChunkStatusReq.status_to_set)
  return status_to_set_;
}
inline void SetChunkStatusReq::set_status_to_set(::google::protobuf::uint32 value) {
  
  status_to_set_ = value;
  // @@protoc_insertion_point(field_set:chunkserver.SetChunkStatusReq.status_to_set)
}

// -------------------------------------------------------------------

// SetChunkStatusRsp

// -------------------------------------------------------------------

// AllocateInodeReq

// uint64 chunk_id = 1;
inline void AllocateInodeReq::clear_chunk_id() {
  chunk_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AllocateInodeReq::chunk_id() const {
  // @@protoc_insertion_point(field_get:chunkserver.AllocateInodeReq.chunk_id)
  return chunk_id_;
}
inline void AllocateInodeReq::set_chunk_id(::google::protobuf::uint64 value) {
  
  chunk_id_ = value;
  // @@protoc_insertion_point(field_set:chunkserver.AllocateInodeReq.chunk_id)
}

// uint32 data_length = 2;
inline void AllocateInodeReq::clear_data_length() {
  data_length_ = 0u;
}
inline ::google::protobuf::uint32 AllocateInodeReq::data_length() const {
  // @@protoc_insertion_point(field_get:chunkserver.AllocateInodeReq.data_length)
  return data_length_;
}
inline void AllocateInodeReq::set_data_length(::google::protobuf::uint32 value) {
  
  data_length_ = value;
  // @@protoc_insertion_point(field_set:chunkserver.AllocateInodeReq.data_length)
}

// -------------------------------------------------------------------

// AllocateInodeRsp

// uint64 slice_id = 1;
inline void AllocateInodeRsp::clear_slice_id() {
  slice_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AllocateInodeRsp::slice_id() const {
  // @@protoc_insertion_point(field_get:chunkserver.AllocateInodeRsp.slice_id)
  return slice_id_;
}
inline void AllocateInodeRsp::set_slice_id(::google::protobuf::uint64 value) {
  
  slice_id_ = value;
  // @@protoc_insertion_point(field_set:chunkserver.AllocateInodeRsp.slice_id)
}

// -------------------------------------------------------------------

// ReadSliceReq

// uint64 slice_id = 1;
inline void ReadSliceReq::clear_slice_id() {
  slice_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ReadSliceReq::slice_id() const {
  // @@protoc_insertion_point(field_get:chunkserver.ReadSliceReq.slice_id)
  return slice_id_;
}
inline void ReadSliceReq::set_slice_id(::google::protobuf::uint64 value) {
  
  slice_id_ = value;
  // @@protoc_insertion_point(field_set:chunkserver.ReadSliceReq.slice_id)
}

// uint32 offset = 2;
inline void ReadSliceReq::clear_offset() {
  offset_ = 0u;
}
inline ::google::protobuf::uint32 ReadSliceReq::offset() const {
  // @@protoc_insertion_point(field_get:chunkserver.ReadSliceReq.offset)
  return offset_;
}
inline void ReadSliceReq::set_offset(::google::protobuf::uint32 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:chunkserver.ReadSliceReq.offset)
}

// uint32 length_to_read = 3;
inline void ReadSliceReq::clear_length_to_read() {
  length_to_read_ = 0u;
}
inline ::google::protobuf::uint32 ReadSliceReq::length_to_read() const {
  // @@protoc_insertion_point(field_get:chunkserver.ReadSliceReq.length_to_read)
  return length_to_read_;
}
inline void ReadSliceReq::set_length_to_read(::google::protobuf::uint32 value) {
  
  length_to_read_ = value;
  // @@protoc_insertion_point(field_set:chunkserver.ReadSliceReq.length_to_read)
}

// -------------------------------------------------------------------

// ReadSliceRsp

// uint32 data_length = 1;
inline void ReadSliceRsp::clear_data_length() {
  data_length_ = 0u;
}
inline ::google::protobuf::uint32 ReadSliceRsp::data_length() const {
  // @@protoc_insertion_point(field_get:chunkserver.ReadSliceRsp.data_length)
  return data_length_;
}
inline void ReadSliceRsp::set_data_length(::google::protobuf::uint32 value) {
  
  data_length_ = value;
  // @@protoc_insertion_point(field_set:chunkserver.ReadSliceRsp.data_length)
}

// bytes data = 2;
inline void ReadSliceRsp::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReadSliceRsp::data() const {
  // @@protoc_insertion_point(field_get:chunkserver.ReadSliceRsp.data)
  return data_.GetNoArena();
}
inline void ReadSliceRsp::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chunkserver.ReadSliceRsp.data)
}
#if LANG_CXX11
inline void ReadSliceRsp::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chunkserver.ReadSliceRsp.data)
}
#endif
inline void ReadSliceRsp::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chunkserver.ReadSliceRsp.data)
}
inline void ReadSliceRsp::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chunkserver.ReadSliceRsp.data)
}
inline ::std::string* ReadSliceRsp::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:chunkserver.ReadSliceRsp.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadSliceRsp::release_data() {
  // @@protoc_insertion_point(field_release:chunkserver.ReadSliceRsp.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadSliceRsp::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:chunkserver.ReadSliceRsp.data)
}

// -------------------------------------------------------------------

// WriteSliceReq

// uint64 slice_id = 1;
inline void WriteSliceReq::clear_slice_id() {
  slice_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 WriteSliceReq::slice_id() const {
  // @@protoc_insertion_point(field_get:chunkserver.WriteSliceReq.slice_id)
  return slice_id_;
}
inline void WriteSliceReq::set_slice_id(::google::protobuf::uint64 value) {
  
  slice_id_ = value;
  // @@protoc_insertion_point(field_set:chunkserver.WriteSliceReq.slice_id)
}

// uint32 offset = 2;
inline void WriteSliceReq::clear_offset() {
  offset_ = 0u;
}
inline ::google::protobuf::uint32 WriteSliceReq::offset() const {
  // @@protoc_insertion_point(field_get:chunkserver.WriteSliceReq.offset)
  return offset_;
}
inline void WriteSliceReq::set_offset(::google::protobuf::uint32 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:chunkserver.WriteSliceReq.offset)
}

// bytes data = 3;
inline void WriteSliceReq::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WriteSliceReq::data() const {
  // @@protoc_insertion_point(field_get:chunkserver.WriteSliceReq.data)
  return data_.GetNoArena();
}
inline void WriteSliceReq::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chunkserver.WriteSliceReq.data)
}
#if LANG_CXX11
inline void WriteSliceReq::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chunkserver.WriteSliceReq.data)
}
#endif
inline void WriteSliceReq::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chunkserver.WriteSliceReq.data)
}
inline void WriteSliceReq::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chunkserver.WriteSliceReq.data)
}
inline ::std::string* WriteSliceReq::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:chunkserver.WriteSliceReq.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WriteSliceReq::release_data() {
  // @@protoc_insertion_point(field_release:chunkserver.WriteSliceReq.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WriteSliceReq::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:chunkserver.WriteSliceReq.data)
}

// -------------------------------------------------------------------

// WriteSliceRsp

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chunkserver

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_chunkserver_2eproto
